# Daily to do list
## Java 

- - -
## Spring   

-- - -
## CS    

- - -
## 알고리즘    

---------
# 오늘의 회고

220327 Spring MVC


———————

th:object = form에서 사용할 객체를 지정
th:field = id, name을 만들어 줌, 값이 있으면 값도 넣어줌 value 로 


폼에서 체크박스, 라디오 버튼, 셀렉트 박스를 사용
￼
위와 같이 추가


체크 박스를 체크하면 HTML Form에서 open=on 이라는 값이 넘어간다.
스프링은 on이라는 문자를 true 타입으로 변환해준다.
(이건 스프링 타입 컨버터가 이 기능을 수행함.)

** 주의 
체크 박스를 선택하지 않고 폼을 전송하면 open이라는 필드 자체가 서버로 전송되지 않는다.

HTML checkbox는 선택이 안되면 클라에서 서버로 값 자체를 보내지 않음.
수정의 경우에는 상황에 따라서 이 방식이 문제가 될 수 있다.
**** 사용자가 의도적으로 체크되어 있던 값을 체크를 해제해도 저장시 아무 값도 넘어가지 않아서 서버 구현에 따라서 값이 오지 않는 것으로 판단해서 값을 변경하지 않을 수도 있다.

이 문제 해결을 위해 스프링은 히든 필드를 만듬(히든 필드를 값이 넘어감)
null이 아닌 false로 받아 줌
명확해짐

이런 것을 타임 리프가 해결해준다.
————————————————————
th:field를 쓰면 타임리프가 자동으로 히든 필드를 만들어준다!
즉, id name value도 대신 만들어주고 체크박스이면 히든 필드 관련된 부분도 해결해 준다!
거기다가 value 값이 true이면 checked를 넣어서 체크도 자동으로 해줌

———————————————————
멀티 체크 박스

￼
ModelAttribute를 사용하게 되면 컨트롤러 내에 어떠한 메소드를 호출해도 다 위의 모델이 담기게 된다.
성능 최적화를 위해서는 static으로 만들어서 사용하는 것도 좋다. 계속 동적으로 변하지 않는 이상은.. 계속 호출하게 됨 근데 엄청난 영향까진 아님..


멀티 체크 박스는 같은 이름의 여러 체크박스를 만들 수 있다. 그런데 문제는 반복해서 HTML 태그를 생성할 떄, 생성된 HTML태그 속성에서 name은 같아도 되지만, id는 모두 달라야 한다.
따라서 타임리프가 체크 박스를 each 루플 안에서 반복해서 만들 떄 임의로 1,2,3 붙여 준다.

이것도 체크박스이다보니 히든 필드가 생긴다. 그래서 null값이 넘어오는 것이 아닌 false가 넘어온다.


—————————————
라디오 버튼

이번엔 자바 enum으로 개발

￼
아까와 마찬가지로 여러 군데에 모두 사용되므로 @ModelAttribute로 사용


타임리프는 프로퍼티 접근 방식으로 게터가 필요함!


라디오 버튼은 비울 수 없다 그래서 히든 필드가 필요가 없다!

타임리프는 enum에 직접 접근할 수 있다.

스프링EL? T


—————————————
셀렉트 박스

여러 선택지 중 하나 선택, 자바 객체로 해 봄.

￼
이건 컨트롤러 생성될 떄마다 불러오긴 함
일단 단순하게 할려고 또 씀

th:field가 또! selected도 해준다. 아까 checked 처럼 은근 번거로움…



————————————————————
메세지, 국제화




- 메시지???
기획자가 화면에 보이는 문구가 마음에 들지 않는다고, “상품명” 이라는 단어를 모두 “상품이름”으로 고쳐달라고 한다.. 그러면?…

일일이 다 고쳐야한다…

이유는 HTML에 메시지가 하드코딩 되어 있어서..

이런 다양한 메시지를 한 곳에서 관리하도록 하는 기능을 메시지 기능 이라고 한다.


￼

이렇게 만들고 key 값을 불러서 사용한다.


- 국제화
메시지에서 한 발 더 나가보면
메시지에서 설명한 메시지 파일(properties)을 각 나라별로 별도로 관리하면 서비스를 국제화 할 수 있다.
예를 들어 언어별로 2개의 파일을 만들어서 분류하면 된다.(en_properties, ko_properties)

이렇게 하면 사이트를 국제화 할 수 있다!

———————————————
스프링 메시지 소스 설정

스프링 부트 메시지 소스 기본 값은
spring.messages.basename=messages 이거 하나만 기본으로 읽는다.

MessageSource를 스프링 빈으로 등록하지 않고, 스프링 부트와 관련된 별도의 설정을 하지 않으면 messages 라는 이름으로 기본 등록 된다.
즉, messages_en.properties, messages_ko.properties 이렇게 파일만 등록하면 자동으로 인식 한다.


- 메시지 파일 만들기
resources 폴더 밑에 messages.properties, messages_en.properties 이렇게 만듬.
자동으로 폴더로 합쳐져 보이나 파일이 2개인  것을 IDE가 그렇게 보여줌.


——————————————————
스프링 메시지 소스 사용


￼
Autowired 해주고

getMessage에서 처음은 code 값이고 두번쨰는 인자값전달할꺼, 세번쨰는 locale 기본값은 기본 basename에서 설정한 기본 이름 메시지 파일을 조회한다.


값을 못찾으면 default message를 준다!


￼
이렇게 argument를 넣어서 값을 받을 수 있다.
안녕 {0}  << 이거였다,…

Locale을 변경해서 국제화를 할수도 있다.



————————————————
웹 애플리케이션에 메시지 적용하기


- 타임리프 메시지 적용
타임리프의 메시지 표현식은 #{…} <<를 사용한다

￼

이렇게 가능

단어라는 것은 일관성 있게 관리될 수 있어야한다. 그러므로.. 최고의 기능
￼
파라미터도 가능!

—————————————————
웹 애플리케이션에 국제화 적용하기

사실상 아까 #{…} << 이렇게 적용한 것으로 거의 끝났다….

저걸로 한국어, 영어 둘 다 변경 가능…

이제 locale만 선택하면 된다.

브라우저의 설정이나  그런걸로 locale에 따라서 알아서 해준다..

￼
Request Header의 Accept-Language를 보면 이거에 따라서 해준다..

그런데,

Accept_Language가 아닌 쿠키나 세션으로 설정으로 언어를 바꾸게 해주면 된다.

스프링은 LocaleResolver를 제공한다..
￼

만약 Locale 선택 방식을 변경하려면 LocaleResolver의 구현체를 변경해서 쿠키나 세션의 값을 따르도록 바꿀 수 있다.


———————————————————————
검증


타입 검증, 필드 검증 특정 필드의 범위를 넘어서는 검증

컨트롤러의 중요한 역할 중 하나는 HTTP 요청이 정상인지 검증하는 것이다.

참고: 클라이언트 검증, 서버 검증
클라이언트 검증은 조작할 수 있으므로 보안에 취약하다.
서버만으로 검증하면, 즉각적인 고객 사용성이 부족해진다.
둘을 섞어서 사용하되, 최종적으로 서버 검증은 필수!
API 방식을 사용하면 API 스펙을 잘 정의해서 검증 오류를 API 응답 결과에 잘 남겨야 한다.


———————————
검증 직접 처리


￼
성공 시나리오

￼
실패 시나리오

실패할 경우 모델에 기존에 입력했던 값들과 오류 결과를 포함하여 다시 상품 등록 폼을 불러서 렌더링 한다. 어떤 값을 잘못 입력 했는지 친절하게 알려주어야 한다..ㅎ


￼
에러로 넘기기 post /add에서 처리 (상품 저장 post)


￼
복합 룰도 적용 가능하고 마지막에 검증에 실패하면 입력 폼으로 다시 돌려주는 if문을 써주고 아닌 경우는 기존 로직 진행

￼
이렇게 th:if로 추가 가능

****중요 :
자세히 보면 ? Safe Navigation Operator로 되어 있다.
만약에 errors가 null 이라면?? NullPointerException 바로 발생..


남은 문제점….
뷰 템플릿에서 중복 처리가 많다. (이름 가격 수량 다 따로 넣어줘야함..)

타입 오류 처리가 안된다.. (int인데 String 입력 이라던지) 컨트롤러 진입 전에.. 죽어버림…400 Bad Request

Item의 price에 문자를 입력하는 것처럼 타입 오류가 발생해도 고객이 입력한 문자가 화면에 남아야 한다.. 근데 Int인데 String을 저장?? 바인딩 자체가 안된다.

결국 입력한 값도 어딘가 별도로 관리가 되어야 한다.


—————————————————————————
Binding Result

파라미터에서 BindingResult 가 Item바로 뒤에 와야 함.. 꼭 꼭


￼
￼
간단하게 수정 가능 th:field가 있어야 함.


@ModelAttribute에 바인딩 시 타입 오류가 발생하면?
 BindingResult가 있으면 오류 정보를 담아서 컨트롤러를 정상 호출, 없으면 400


- BindingResult에 검증 오류를 적용하는 3가지 방법
 @ModelAttribute의 객체에 타입 오류 등으로 바인딩이 실패하는 경우 스프링이 FieldError 생성해서 BindingResult에 넣어준다.
직접 넣어준다.
Validator 사용


주의 :
BindingResult는 검증할 대상의 바로 다음에 와야한다.
순서가 중요

BindingResult는 Error를 상속 (둘 다 인터페이스)

정리 :
BindingResult, FieldError, ObjectError를 사용해서 오류 메시지를 처리하는 방법은
오류가 발생하는 경우 고객이 입력한 내용이 모두 사라진다 문제 해결을 해보자….

————————————————
FieldError ObjectError


￼
이렇게 보면 리젝을 당할 떄 리젝당할 때 값을 갖고 있음 그래서 그걸 돌려주면 됨.

사용자 입력 데이터가 바인딩 되는 시점에는 값을 갖기 힘든데(숫자들어와야하는데 문자 들어오는경우)  스프릉이 BindingResult에 Item보다 먼저 저장한다.

타임리프에서 값이 유지되는 방법은
th:field는 똑똑한데.. 오류가 없으면 그냥 모델에 있는 값을 출력하고 오류가 있으면 FieldError에 보관된 값을 사용해서 출력해준다..


—————————————————
오류 코드와 메시지 처리

￼
이번에는 errors.properties라는 하나의 resource를 만들고 그 안에 값을 정의하고 불러오는 것이다.
이 곳에서 argument도 불러올 수 있음.

에러 메시지 순서는, code의 1,2, 순서와 다 없으면 default값.

아직은 기존보다,.. 더 복잡하다.. 아직은


———————————————
오류 코드와 메시지 처리 2

컨트롤러는 이미 알고 있다 검증해야할 객체를.. 바로 앞 객체를 선택


- rejectValue, reject

를 사용하면 filederror안써도 된다.

￼
훨씬 간펺다ㅏ..

근데 errorCode를 보면 전체를 입력하지 않고 어떠한 규칙이 있다.
이 오류 코드는 메시지에 등록된 코드가 아니라 messageResolver를 의한 오류 코드이다.

- 축약된 오류 코드
FieldError() 를 직접 다룰 때는 오류 코드를 range.item.price와 같이 모두 입력함.
근데 여기는 간단히 입력함 이건 MessageCodesResolver를 이해해야 함.

——————————————————
오류 코드 설계

오류 코드를 지금 처럼
required.item.itemName 이렇게 자세히
required 처럼 간단히 만들 수도 있따.

간단히 만들면 범용성은 좋으나 세밀하게 작성은 어렵다.
반대로 너무 자세하면 범용성이 떨어진다.
가장 좋은 방법은 범용성으로 사용하다가 세밀하게 작성해야 하는 경우는 세밀하게 작성하는 단계를 두는 방법이 좋다.


required.item.itemName 과 required 가 있다면
가장 디테일한 프로퍼티를 먼저 선택한다.

이렇게 하면 코드의 수정이 필요 없이 프로퍼티의 값 변경만으로도 수정을 할 수 있다!!

————————————
MessageCodesResolver

￼
메시지코드리졸버에서 errorCode를 required, 객체 이름을 item 필드를 itemName으로 하면 위와 같은 순서로 찾는다.

가장 디테일한 것, 객체 빼고 필드 명, 숫자,문자, errorCode

- 기본 메시지 생성 규칙
￼

rejectValue, reject는 내부에서 MessageCOdesResolver를 사용한다.

￼
이렇게 다들 들고 있다가 순서대로 내부에서 찾는다..

그렇다면 에러.객체.필드 순서로 만들면 규칙을 조금 더 지킨다..

이것을 활용해서

레벨을 매겨서 매칭을 하는 방법도 있다.
￼



- ValidationUtils
￼
hasText 쓴거처럼 단순한 Empty 공백 같은 단순한 기능 제공

—————————————
스프링이 직접 만든 오류 메시지 처리

검증 오류 코드는 2가지로 나눌 수 있다.
- 개발자가 직접 설정한 오류 코드 >> resuectValue() 를 직접 호출
- 스프링이 직접 검증 오류에 추가한 경우 (주로 타입)

스프링이 직접 만든 것에도 아까처럼 레벨이 나뉘어서 있고. default 메시지도 있다..ㅎ
(그것이 아까 길게 나오던 것)
￼
이것…

이걸 메시지를 바꿔줄 수 있다.
￼
이런식으로 스프링 기본 typeMismatch에서 합쳐서 할 수 있음…

결과적으로 소스코드를 하나도 건들지 않고 원하는 메시지를 단게별로 설정할 수 있다.




————————————————
Validator 분리

컨트롤러가 너무 많은 일을 하고 있음 (검증만 훨씬 많음)
단일 책임..ㅎ

￼
이렇게 만들고 ItemValidator를 클래스로 하나 만들고 Validator를 상속 받는다.
그러면 그 많던 코드를 다른 곳에서 불러오면 된다.


컨트롤러에서 검증 로직이 차지하는 부분은 매우 크다. 이런 경우 별도의 클래스ㅇ로 역할을 분리해주는 것이 좋다. 재사용도 가능(실제로는 그렇게는 많이 ..안씀)

￼
2가지로 구성된다. 일단 supports는 나중에 확인 (HandlerAdapter에서도 쓰인 그런 느낌 아닐까 예상)

———————————————————
Validator 분리

스프링이 Validator 인터페이스를 별도로 제공하는 이유는 체계적인 검증 기능을 도입하기 위해서. 

\
￼
바인더를 설정해주고
￼
이번에는 @Validated 애노테이션을 추가하면 검증기를 자동으로 추가.
그러면 검증기를 추가하는 것을 안해도 됨!
//        itemValidator.validate(item, bindingResult); <<< 이것

그런게 **어떠한 검증기를 사용해야할지 supports에서 정해준다!


- 글로벌 설정도 가능 - 모든 컨트롤러에 다 적용

￼

이런식으로..

기존 컨트롤러의 @InitBinder를 제거해도 정상 동작.
글로벌 설정을 하면,.. BeanValidator가 자동으로 등록되지 않는다고 함.
(뒤에 자세히)
참고로 글로벌 설정을 하는 일은 정말 드물다…

참고 : 검증 시 @Validated, @Valid 둘 다 사용 가능
@Valid는 javax꺼임 의존관계 추가가 필요하고 설정이 조금 다름
