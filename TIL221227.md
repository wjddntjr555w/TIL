# Daily to do list
## Java 

- - -
## Spring   

-- - -
## CS    

- - -
## 알고리즘    

---------
# 오늘의 회고

221226 SPRING JPA


jpa는 스프링 만큼이나 방대함 하지만 한번 배워두면 데이터 접근 기술에서 큰 생산성 향상을 얻을 수 있음.

실무에서는 스프링 데이터 jpa, querydsl이라는 기술을 함께 사용함.



ORM 개념  - sql 중심적인 개발의 문제점

jpa와 모던 자바 데이터 저장 기술

- sql 중심적인 개발의 문제점
무한 반복, 지루한 코드,,, CRUD sql 후 자바 객체로…
자바 객체를 sql로.. 

객체 CRUD - 필드 추가
￼
Insert select update 다 각각 만들어야함..

sql에 의존적인 개발을 피하기 어렵다..


패러다임의 불일치 : 
객체를 관계형 db에 저장하려면 sql로 번환 후 저장해야 함
이 중간에 객체를 sql문으로 바꾸는 것은 누가 하는가? 개발자가 해야함..
중간에서 sql 매퍼 역할을 해준다.. 그리고 차이는 상속, 연관관계 데이터 타입, 데이터 식별 방법 다름
￼
쿼리를 두번으로 쪼개서 저장해야함

처음 실행하는 sql에 따라 탐색 범위가 결정된다.
￼

엔티티 신뢰 문제가 생긴다. 
￼
DAO 코드를 열어서 어떤 sql이 실행되는지까지 확인해야함.. 

모든 객체를 미리 로딩할 수는 없다..( 연관관계가 있는 것들으 다 탐색하기 어렵다 join을 다 탐색 불가능) 

즉 상황에 따라 동일한 회원 조회 메서드를 여러번 발생하게 된다.
￼

나아가 계층형 아키텍처에서 진정한 의미의 계층 분할이 어렵다.

객체를 자바 컬렉션에 저장하듯이 db에 저장할 수는 없을까? 에서 jpa가 나옴
 

jpa란
java persistence Api
ORM : 객체 관계 매핑
객체는 객체대로 설계
관계형 데이터베이스는 관계형 데이터베이스대로 설계
ORM 프레임워크가 중간에서 매핑
대중적인 언어에는 대부분 orm 존재

￼
jpa는 app과 jdbc 사이에서 동작 함.

저장
DAO에서 객체를 넘겨주면 JPA가 Entity를 분석을해서 Insert SQL문을 생성함
JDBC API를 사용하여 DB에 전달, 패러다임 불일치 해결

조회
DAO에서 find를 보내면 select query를 생성
JDBC API를 사용, result set 매핑 + 멤버 객체를 만들어서 전달해줌
패러다임 불일치 해결

JPA는 하이버네이트(오픈소스)를 구현체로 주로 사용
JPA는 인터페이스 모음 구현체는 (하이버네이트, EclipseLink 등)

왜? JPA를 사용해야 하는가
1. sql 중심적인 개발에서 객체 중심으로 개발
2. 생산성
￼
3. 유지보수
￼
새로운 필드가 생겨도 부가적인 sql 생성이 필요 없이 jpa가 자동으로 만들어줌

4. 패러다임 불일치 해결
￼
￼
jpa에 기본 컨셉 = jpa는 자바 컬렉션이다 라고 이해..해도됨
￼
** 동일한 트랜잭션에서 조회한 엔티티는 같음을 보장!!!

5. 성능
보통 계층이 나뉘어 있으면 2가지 기능을 할 수 있음 : 캐시, 버퍼링 write 
jpa 이런 성능 최적화를 자동으로 적용 함
— 1차 캐시와 동일성 보장
￼
자동 캐시 적용 sql이 한번만 적용된다!!

— 트랜잭션을 지원하는 쓰기 지연
￼
트랜잭션을 commit할 떄까지 insert sql을 모음
jdbc batch sql 기능을 사용해서 한번에 sql 전송 (즉 네트워크 통신 1번만)
성능 최적화 가능, 옵션 키고 끌 수 있음

— 지연 로딩
￼
지연 로딩 : 객체가 실제 사용될 떄 로딩
즉시 로딩 : join sql로 한번에 연관된 객체까지 미리 조회
지연 : 사용하지않는 것들이 로딩되지 않도록 함
즉시 : 자주 사용되는 경우 즉 멤버를 불러올 때 팀도 같이 불러오는 경우가 많다면 오히려 1번의 sql 호출이 더 효울적
이것을 간단한 코드 2줄 정도로 활용 가능

6. 데이터 접근 추상화와 벤더 독립성
7. 표준

orm은 객체와 rdb 두 기둥위에 있는 기술.. 즉 둘 다 잘 알아야한다


- jpa 설정
logging.level.org.hibernate.SQL=DEBUG logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

하이버네이트가 생성하고 실행하는 sql을 확인.
sql에 바인딩 되는 파라미터를 확인할 수 있게 함

둘 다 켜면…(logger, systemout 둘 다 로그가 출력되면서 같은 로그가 중복해서 출력)


———————————————————
JPA 적용 - 개발

jpa에서 가장 중요한 부분은 객체와 테이블을 매핑하는 것이다.
jpa가 제공하는 애노테이션을 사용해서 Item 객체와 테이블을 매핑해보면

@Entity 애노테이션으로도 가능, @Table(name = “Item”) 지정도 있으나 객체명과 이름이 같으면 생략

@GeneratedValue(strategy = GenerationType.IDENTITY) : db에서 자동으로 값 부여
￼
@Column으로 컬럼값 지정 가능 이름 동일하면 비워도 됨

@Entity : JPA가 사용하는 객체라는 뜻이다. 이 에노테이션이 있어야 JPA가 인식할 수 있다. 이렇게 @Entity 가 붙은 객체를 JPA에서는 엔티티라 한다

@Id : 테이블의 PK와 해당 필드를 매핑한다. 

@GeneratedValue(strategy = GenerationType.IDENTITY) : PK 생성 값을 데이터베이스에서 생성하는 IDENTITY 방식을 사용한다. 예) MySQL auto increment 

@Column : 객체의 필드를 테이블의 컬럼과 매핑한다. 
	name = "item_name" : 객체는 itemName 이지만 테이블의 컬럼은 item_name 이므로 이렇게 매핑했다. 
	length = 10 : JPA의 매핑 정보로 DDL( create table )도 생성할 수 있는데, 그때 컬럼의 길이 값으로 활용된다. 
	( varchar 10 ) @Column 을 생략할 경우 필드의 이름을 테이블 컬럼 이름으로 사용한다. 
참고로 지금처럼 스프링 부트와 통합해서 사용하면 필드 이름을 테이블 컬럼 명으로 변경할 때 객체 필드의 카멜 케이스를 테이블 컬럼의 언더스코어로 자동으로 변환해준다. (사실 name= “item_name”은 생략해도 됨 자동 카멜 케이스를 변경해줌)
itemName item_name , 따라서 위 예제의 @Column(name = "item_name") 를 생략해도 된다.

JPA는 public, protected의 기본 생성자가 필수!! 
**** JPA의 모든 데이터 변경은 트랜잭션 안에서 이뤄진다.

￼
JPA는 반드시 EntityManager 를 의존관계 주입을 받아야한다.

** persist ===== 영구히 보존한다.

savet시 em.persist(Item) 하면
￼
Item의 정보들을 가져와서 알아서 저장해줌….

￼

￼
findall을 할 때는 jpql이라는 것을 사용해서 sql문 처럼 사용(sql과 문법이 거의 비슷 좀 다름)
단… 동적 쿼리에 약함 즉.. findall 처럼 정적으로 가능한 것에 사용하는 게 좋을듯

jpa의 모든 동작은 엔티티 매니저를 통해 이루어진다. 엔티티 매니저는 내부에 데이터 소스를 갖고 있고 데이터베이스에 접근할 수 있다.
jpa의 모든 데이터 변경은 트랜잭션 안에서 이루어져야 한다.(조회는 트랜잭션 없이도 가능)

이 예제는 repository에 걸었지만 일반적으로는 비즈니스 로직을 시작하는 서비스 계층에 트랜잭션을 걸어준디ㅏ.

jpa를 설정하려면 트랜잭션매니저 엔티티매니저 데이터소스 등등 다양한 설정을 해야하지만 스프링 부트가 이 과정을 모두 자동화 해준다!


******* 영속성 컨텍스트.. 꼭 알아야지 jpa의 원리를 이해할 수 있다.

jpa에서 단순히 pk를 기준으로 조회하는 것이 아닌 여러 데이터를 복잡한 조건으로 데이터를 조회하려면? 
JPQL 을 사용

JPQL은 엔티티 객체를 대상으로 sql을 실행, 대소문자 구분
sql과 문법은 거의 비슷

—————
동적 쿼리 문제..
JPA를 사용해도 동적 쿼리 문제가 있다. querydsl이라는 기술 사용하면 깔끔하게 사용 가능

——————————
jpa 예외 변환
EntityManager는 순수한 jpa 기술이고 스프링과는 관계가 없다.
즉 예외가 발생하면 jpa관련 예외를 발생 시킴
￼
방법은 @Repository 기능
@repository가 붙으면 예외 변환 AOP 적용 대상이 된다!

￼
Repository에서 예외 변환 AOP 프록시를 거쳐서 DataAccessException으로 변경되어 서비스 계층으로 전달해주게 된다.
(CGLIB)
