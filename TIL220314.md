# Daily to do list
## Java 

- - -
## Spring   

-- - -
## CS    

- - -
## 알고리즘    

---------
# 오늘의 회고

220314 HTTP 웹 기본 지식

—————————————

클라이언트에서 서버로 데이터 전송

데이터 전달 방식은 크게 2개

- 쿼리 파라미터를 통한 데이터 전송
GET, 주로 정렬 필터(검색어)

- 메시지 바디를 통한 데이터 전송
POST, PUT, PATCH, 회원가입, 상품 주문, 리소스 등록, 리소스 변경


ex) 4가지 상황

- 정적 데이터 조회
￼
쿼리 파라미터 미사용
이미지, 정적 텍스트 문서 조회는 GET 사용
쿼리 파라미터 없이 단순한 리소스 경로만으 조회 가능

- 동적 데이터 조회
￼
쿼리 파라미터를 사용, 쿼리 파라미터를 기반으로 정렬 필터해서 결과를 동적으로 생성함.

주로 검색, 게시판 목록에서 정렬 필터(검색어)
조회는 GET 사용, GET은 쿼리 파라미터 사용해서 데이터를 전달

- HTML Form  데이터 전송
￼

POST 전송 - 저장, Form에서 submit을 누르면 자동으로 HTTP 메시지를 만들어 줌.
GET으로 하면 메시지 바디에 정보가 담기는 것이 아닌 queryString으로 정보가 담겨서 안됨.


multipart/form-data : 파일 전송도 할려고 하면 사용
￼
이렇게 알아서 웹브라우저가 잘라줌, 여러개 컨텐츠에 대한 데이터를 보낼 수 있다.


정리:
HTML Form submit시 POST 전송
(예) 회원 가입, 상품 주문, 데이터 변경

Content-Type: application/x-www-form-urlencoded 사용
 form의 내용을 메시지 바디를 통해서 전송, 전송 데이터를 url encoding 처리
(예) abc김 >> abc%EA%B9%80

Content-Type: multipart/form-data
 파일 업로드 같은 바이너리 데이터 전송 시 사용
 다른 종류의 여러 파일과 폼의 내용 함께 전송 가능

HTML Form은 GET 전송도 가능

참고 : HTML Form 전송은 GET, POST만 지원


HTTP API 데이터 전송

이것은 예를 들어 앱에서 클라이언트에서 서버로 전송한다고 하면 이걸 API 데이터 전송한다고 함.
￼
아까 보았던 HTTP 메시지를 만들어서 전송을 하면 됨

정리 :
서버 to 서버 : 에서 많이 사용 
앱 클라이언트 : 에서도 사용
웹 클라이언트 : HTML에서 Form 전송 대신 자바 스크립트를 통한 통신에 사용(AJAX)

POST PUT PATCH 메시지 바디를 통해 데이터 전송
GET : 조회, 쿼리 파라미터로 데이터 전달
Content-Type : application/json을 주로 사용 (사실상 표준)
예) TEXT, XML, JSON 등등


——————————————
HTTP API 설계 예시

HTTP API - 컬렉션
 POST 기반 등록 (예) 회원 관리 API 제공

HTTP API - 스토어
 PUT 기반 등록 (예) 정적 컨텐츠 관리, 원격 파일 관리

HTML FORM 사용
 웹 페이지 회원 관리

￼
URI는 리소스, 행동은 메소드가 !!

회원 정보 수정에서 PUT보다는 PATCH를 주로 사용한다, 그 이유는 PUT은 테이블을 완전히 덮어버리는 것이다. 혹시나 클라이언트에서 정보를 누락해서 서버로 전송한다면 누락된 정보로 서버가 그대로 덮어버려서 어떤 정보가 누락되었는지 찾을 수 없게 된다. 하지만 PATCH는 덮어쓰기가 아닌 수정으로 누락되었다면 누락된 테이블은 덮어지지 않는다.


- POST 신규 자원 등록 특징
POST로 리소스를 등록하게 되면 신규 리소스를 식별할 수 있는 URI를 서버가 만들어 준다. 그래서 응답할 때 URI에 전달, 아니면 메세지 바디에 실어서 전달.

클라이언트는 등록될 리소스의 URI를 모른다.
*****서버가 새로 등록된 리소스 URI를 생성해준다.
이런 형식을 컬렉션(Collection)
- 서버가 관리하는 리소스 디렉토리
- 서버가 리소스의 URI를 생성하고 관리
- 여기서 컬렉션은 /members

- PUT 기반 등록
PUT은 기본에 있으면 완전 덮어쓰기, 없으면 새로 생성

클라이언트가 리소스 URI를 알고 있어야 한다.
- 파일을 등록할 때 {filename}을 넣어줘야 함. URI를 클라이언트가 식별
- PUT /files/star.jpg
**클라이언트가 직접 리소스의 URI를 지정한다.
이런 형식을 스토어(Store)
- 클라이언트가 관리하는 리소스 저장소
- 클라이언트가 리소스의 URI를 알고 관리
- 여기서 스토어는 /files

정리 : POST는 컬렉션 방식, PUT은 스토어 방식, 클라이언트가 리소스 URI를 아는가 유무


- HTML FORM 사용
HTML FORM은 GET, POST만 지원
AJAX 같은 기술을 사용해서 해결 가능 -> 회원 API 참고
여기서는 순수 HTML, HTML FORM 이야기
GET, POST만 지원하므로 제약이 있음…

￼

이렇게 설정하는것도 가능..

회원 등록의 경우 POST로 요청하였다가 회원 등록에 실패했을 경우 등록 폼과 URI가 같은 경우 새로고침만으로도 페이지를 다시 만들 수? 있는데 URI가 다르면 아예 다른 경로로 요청을 보내야 한다..

회원 수정 폼과 회원 수정의 경우 submit 버튼을 누르고 POST 메소드로 요청을 보내면서 URI는 안바꿔도 되는 편함이 생긴다.

HTML FORM은 GET, POST만 지원
컨트롤 URI를 사용해야함. 동사를 사용
컨트롤 URI는 /new, /edit, /delete
HTTP 메서드로 해결하기 애매한 경우 사용 (HTTP API 포함)
**실무에서 많이 사용 ㅎㅎ



정리 :

HTTP API - 컬렉션 이것은 POST 기반, 서버가 리소스 URI를 결정
HTTP API - 스토어 이것은 PUT 기반, 클라이언트가 리소스 URI를 결정
HTML FORM 사용 - 순수 HTML+ HTML FORM 사용, GET POST만 사용 컨트롤 URI사용 해야함

***참고하면 좋은 URI 설계 개념
좋은 practice

문서 : 단일 개념(파일 하나, 객체 인스턴스, 데이터베이스 row) 예) /members/100

컬렉션 :
서버가 관리하는 리소스 디렉터링
서버가 리소스의 URI를 생성하고 관리
예 ) /members

스토어 :
클라이언트가 관리하는 자원 저장소
클라이언트가 리소스의 URI를 알고 관리
예) /files

*대부분 컬렉션을 사용, 파일을 가끔 스토어

컨트롤러(controller), 컨트롤 URI :
문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행
동사를 직접 사용, (예) /members/{id}/delete 등..
애매하고 어쩔 수 없는 상황이 많고 실무에서 많이 사용함..



————————————————
HTTP 상태 코드 
클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능

1xx(Informational)	 요청이 수신되어 처리중 (잘 사용하지 않음0
2xx(Successful)	요청 정상 처리!!
3xx(Redirection)	요청을 완료하려면 추가 행동이 필요
4xx(Client Error)	클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음
5xx(Server Error)	서버 오류, 서버가 정상 요청을 처리하지 못함

만약 모르는 상태 코드가 나타나면?..
클라이언트는 상위 상태코드로 해석해서 처리 즉 백의 자리를 보고 처리



2xx (Successful)
200 : OK, 요청 성공

201 : Created, : 요청 성공해서 새로운 리소스가 생성됨 
￼


202 : Accept : 요청이 접수되었으나 처리가 완료되지 않았음
예) 요청 접수 후 1시간 뒤에 배치 프로세스가 요청을 처리함 ( 잘 사용하지 않음)

204 : No Content : 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음..
예) 웹 문서 편집기에서 save 버튼
save 버튼의 결과로 아무 내용이 없어도 된다. save버튼을 눌러도 같은 화면을 유지해야 한다.
결과 내용이 없어도 204메시지만으로 성공을 인식할 수 있다.

——————————————
3xx - 리다이렉션 : 요청을 완료하기 위해 유저 에이전트의 추가 조치가 필요

리다이렉션 이해 :
웹 브라우저는 3xx응답의 결과에 Location헤더가 있으면, Location 위치로 자동 이동
￼
요청을 왔는데 3xx코드와 Location의 값이 있다면 응답을 받은 후 새로운 Location의 페이지를 오픈함.

리다이렉션 종류 :
- 영구 리다이렉션 : 특정 리소스의 URI가 영구적으로 이동
예) /members -> /users

- 일시 리다이렉션 : 일시적인 변경
주문 완료 후 주문 내역 화면으로 이동
PRG : Post/Redirect/Get

- 특수 리다이렉션
결과 대신 캐시를 사용

영구 리다이렉션 : 301, 308
리소스의 URI가 영구적으로 이동
원래의 URL을 사용하면 안됨, 검색 엔진 등에서도 변경 인지
301 Moved Permanently
- 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음(MAY)
308 Permanent Redirect
- 301과 기능은 같음
- 리다이렉트시 요청 메서드와 본문 유지(처음 POST를 보내면 리다이렉트도 POST)
(실무에서는 거의 이렇게 사용하지 않음, 그냥 POST로 와도 GET으로 돌리느 경우가 많음 페이지가 변하면 데이터도 거의 다 바뀌기 떄문에)


일시적인 리다이렉션 : 302, 307, 303 (실무에서 많이 씀)
리소스의 URI가 일시적으로 변경
따라서 검색 엔진 등에서 URL을 변경하면 안됨

302 : Found
- 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음(MAY)
307 Temporary Redirect
- 302와 기능은 같음
- 리다이렉트시 요청 메서드와 본문 유지(요청 메서드를 변경하면 안된다. MUST NOT)
303 : See Other
- 302와 기능은 같음
- 리다이렉트시 요청 메서드가 GET으로 변경


PRG : Post/Redirect/Get
일시적인 리다이렉션 - 예시

POST로 주문 후에 웹 브라우저를 새로고침하면?
새로고침은 다시 요청
중복 주문이 될 수 있다.
이렇게 되면 새로고침마다 마지막 POST요청을 계속 서버로 보내어 중복 주문이 계속 발생함

이걸 해결하기 위해 PRG 등장

POST로 주문 후에 새로고침으로 인한 중복 주문 방지
POST로 주문후에 주문 결과 화면을 GET 메서드로 리다이렉트(주문 결과 페이지를 따로 만듬)
새로고침해도 결과 화면을 GET으로 조회 ( 마지막이 GET 메서드)
중복 주문 대신에 결과 화면만 GET으로 다시 요청 ( 중복 주문 대신 결과가 GET)

PRG 이후 리다이렉트
URL이 이미 POST -> GET으로 리다이렉트 됨
새로 고침 해도 GET으로 결과 화면만 조회
사용자 입장에서도 좋음 (실수로 누르기도 함)
서버도 좋음 클라에서 미리 막음


302, 307, 303.
잠깐 정리:
302 -> GET으로 변할 수 있음
307 -> 메서드가 변하면 안됨
303 -> 메서드가 GET으로 변경

역사.. 
처음 302 스펙의 의도는 HTTP 메서드를 유지하는 것
그런데 웹 브라우저들이 대부분 GET으로 바꾸어버림(일부는 다르게 동작)
그래서 모호한 302를 대신하는 명확한 307, 303이 등장함

현실
307, 303을 권장하지만 현실적으로 이미 많은 애플리케이션 라이브러리들이 302를 기본값으로 사용
자동 리다이렉션시에 GET으로 변해도 되면 그냥 302를 사용해도 큰 문제 없음


기타 리다이렉션 : 300, 304

300 Multiple choices: 안씀

304 Not Modified (많이 씀):
캐시를 목적으로 사용
클라이언트에게 리소스가 수정되지 않았음을 알려준다.
따라서 클라이언트는 로컬PC에 저장된 캐시를 재사용한다. (캐시로 리다이렉트 한다.)
304 응답은 응답에 메시지 바디를 포함하면 안된다. (로컬 캐시를 사용해야 하므로)
조건부 GET, HEAD 요청시 사용
(서버가 클라이언트에게 “클라야 니가 너의 캐시에 있는걸 써” 라고 전달을 하는 거)

————————————
4xx 클라이언트 오류, 5xx 서버 오류

4xx 클라이언트 오류
클라이언트의 요청이 잘못된 문법등으로 서버가 요청을 수행할 수 없음
***오류의 원인이 클라이언트에 있음
중요!! 클라이언트가 이미 잘못된 요청, 데이터를 보내고 있기 때문에, 똑같은 재시도가 실패함
400대 오류는 클라이언트에 잘못이 있기에 메시지를 수정하여야 한다.
500대 오류는 클라이언트에 잘못이 없기에 나중에 서버를 복구하고 똑같은 요청을 보내면 성공할수도 있따!.

- 400 : Bad Request
클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음.

요청 구문, 메시지 등등 오류
클라이언트는 요청 내용을 다시 검토하고, 보내야함
예) 요청 파라미터가 잘못되거나, API 스펙이 맞지 않을 때
(서버 개발자가 400오류로 미리 빼줘야 한다. 철저하게 벨리데이션해서 잘못이 400이라고 말해줘야 한다.)

- 401 : Unauthorized
클라이언트가 해당 리소스에 대한 인증이 필요함

인증 되지 않음
401 오류 발생 시 응답에 WWW-Authenticate헤더와 함께 인증 방법을 설명

참고 :
인증(Authentication) : 본인이 누구인지 확인, (로그인)
인가(Authorization) : 권한부여( ADMIN처럼 특정 리소스에 접근할 수 있는 권한,
인증이 있어야 인가가 있음)
(인가는 인증에서 한단계 나아간 권한 부여, 인증은 단순한 로그인)
오류 메시지가 Unauthorized이지만 인증 되지 않음(이름이 아쉽…)


- 403 : Forbidden
서버가 요청을 이해했지만 승인을 거부함

주로 인증 자격 증명은 있찌만, 접근 권한이 불충분한 경우
예) admin 등급이 아닌 사용자가 로그인을 한 경우

- 404 : Not Found
요청 리소스를 찾을 수 없음

요청 리소스가 서버에 없음
또는 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶을 때 (403이 아닌 이 사이트를 숨기고 싶을 떄 완전 없다고 해버림)


5xx (Server Error)
서버 오류

서버 문제로 오류 발생
서버에 문제가 있기 때문에 재시도 하면 성공할 수도 있음!

- 500 Internal Server Error
서버 문제로 오류 발생, 애매하면 500 오류

- 503 Service Unavailable
서비스 이용 불가

서버가 일시적인 과부화 또는 예정된 작업으로 잠시 요청을 처리할 수 없음
Retry-After 헤더 필드로 얼마뒤에 복구되는지 보낼 수도 있음
(근데 대부분 예측 불가능한 오류라.. 거의 500이 나옴)

**** 중요 : 서버 개발자는 500대 에러를 만들면 안된다..
예를 들어) 고객의 잔고가 부족하다. 이런 에러를 500으로 만들면 안된다. 500에러는 진짜 서버가 완전 심각한 오류가 터졌을 떄를 말하는 것이다. 모니터링 시스템도 500에 돌고 이런게 동작하는데.. 서비스가 안되는건 에러가 아니다.


